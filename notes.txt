####################################################################################################
# WEEK 1
####################################################################################################

####################################################################################################
# Strings

# incrementing and decrementing values (strings and floats)
set inventory:4x100m-womens-final 1000
get inventory:4x100m-womens-final
# decrement
decrby inventory:4x100m-womens-final 1
get inventory:4x100m-womens-final
type inventory:4x100m-womens-final
object encoding inventory:4x100m-womens-final

# set to non-int string, polymorphism: differents types of data for the same key
set inventory:4x100m-womens-final "Sold Out"
# data type may change, no schema
object encoding inventory:4x100m-womens-final
# now this will fail because the encoding is not int but text: (error) ERR value is not an integer or out of range
decrby inventory:4x100m-womens-final 1

# set the key to 0
set inventory:4x100m-womens-final 0

# short increment by 1
incr inventory:4x100m-womens-final

# short decrement by 1
decr inventory:4x100m-womens-final


 ####################################################################################################
# Hashes: a way to store and retrieve an object, mini key-value store within the key

# set one or more fields in hash
hset event:judo capacity 12000 location "Nippon Budokan" ticket_price:gold 100 availability:gold 8000
# check for existence of a field with hexist
hexists event:judo capacity
# get field value, nil if does not exist
hget event:judo capacity
hget event:judo ticket_price:gold
hget event:judo timezone

# increment the number of tickets by the number of tickets sold. read value back
hincrby event:judo availability:gold -10
hget event:judo availability:gold

# return values for all of the fields <= don't use in prod
hgetall event:judo


# get all keys or all values <= don't use in prod
hkeys event:judo
hvals event:judo

# hscan <= use this in prod instead
# start at cursor 0 and use a matching pattern availability:*

# set a timezone field then remove it with hdel
hset event:judo timezone JST
hget event:judo timezone
hdel event:judo timezone

# session objects can be saved as a string, but you could use a hash
- hmset session:a3fWa ts 1518132669 host www.example.org
- hincrby session:a3fWa requests 1
- expire session:a4fWa 60


####################################################################################################
# Lists: ordered collection of elements (strings)
- duplicates are allowed
- elements can be added or remove at either end (left, right) or relative to another element
- simple way to implement stacks, queues, or other data structures
- a structure can only be comprised of strings, no nesting
- implemented as double-linked array (constant time insertion left or right / head or tail)

# add to left or right of the list
lpush
rpush

# remove from left or right
lpop
rpop 

# add 3 orders to 4x100m-womens-final (create list if non-existent)
lpush orders:4x100m-womens-final jane:4 bill:5 charlie:6
# find length, 3 in this case
llen orders:4x100m-womens-final
# retrieve elements, two parameters: start and stop indexes, the whole list this time
# indexes start at zero, but the list displayed with start at 1
lrange orders:4x100m-womens-final 0 -1

# lpush + rpush <= implement a stack
# rpush + lpop  <= implement a queue

rpush waitlist:basketball-mens-qual brian:2 kate:7 kevin:9
lrange waitlist:basketball-mens-qual 0 -1

# remove rightmost element
rpop rpop orders:4x100m-womens-final
# remove leftmost element
lpop waitlist:basketball-mens-qual

# List use cases
- activity stream: most recent activity (e.g. facebook posts)
  # add items to the left of the list
	lpush stream one two three four five
  # get latest 3 items
  lrange stream 0 2
  # prune the list, retain 4 elements: five four three two
  ltrim stream 0 3
- inter-process communication
  # queue that supports producer-consumer pattern
  # produce
  rpush queue "event1"
  # keep order: get the events in the same order they produced
  # pop from the opposite side you pushed
  lpop queue


# Quiz

# execute:
rpush list-two a b c d
# a b c d
lpop list-two
# pops 'a', remain: b c d

# question: output?
lindex list-two 1
# get element at 2nd position (index 1) => c
 

# execute:
set list-four abc
rpush list-four a b c d


# question: What does list-four now contain?
# an error occurs. 'set' does not create a list, it creates a string so the 'rpush' fails


####################################################################################################
# Data Structures 1: Recap

Basic Redis Data Structures:
- Keys & Expiration
- Strings
- Hashes
- Lists


####################################################################################################
# Sets: unordered collection of strings
- store and manipulate strings
- set operations: differences, intersection, unions
- elements: just strings. no hierarchy, compound structures, etc


# add 3 elements to set
sadd venues "Olympic Stadium" "Nippon Budokan" "Tokyo Stadium"
sscan venues 0 match *
# try to add existing element again => return value of 0
sadd venues "Olympic Stadium"

# check if element exists
# exists => return value of 1
sismember venues "Nippon Budokan"
# does not exist => return value of 0
sismember venues "Eiffel Tower"

# remove elements
# by value
sadd values "Eiffel Tower"
srem venues "Eiffel Tower"
# remove random element
# remove 2 rndom elements
spop venues 2

# difference between sets
sdiff

# create two new sets
sadd "venue-subway:Makuhari Messe" line1 line2 line3 line4
sadd "venue-subway:Tokyo Tatrum" line2 line4 line7

# common values between sets (sinter => sets intersection)
# returns numbered list: line2 line4
sinter "venue-subway:Makuhari Messe" "venue-subway:Tokyo Tatrum"

# other commands
sdiff
sunion

# Use cases for sets:
- tag cloud
  # maintain separate list of tags for each object we want to tag
  sadd wrench tool meta
  # all tags belonging to object
  sscan
  # tags accross objects
  sinter
  # set of all tags
  sunion
- create record of unique visitors of each page on our website for a given period of time
  # create set for each unique URL and time period, e.g.: about.html and 10th of February 2018
  # ech visitors cookie can be recorded as a member of the set
  # the set now contains all the unique visitors to that page within the time period, which can be retrieved with the sscan command
  # since the expiration relates to the key are not the elements in the set, then all elements are removed when the key is expired


####################################################################################################
# sorted sets
- collection of unique strings
- score associated with each element, floating point number that provides a sorting order for the elements. ties => alphabetic
- manipulate by value, position, score or lexigraphically
- set command sorted sets: union, intersection


# add element to sorted set: zadd
- zadd nx / xx => add if value does not exists / update an existing element

# add element with score value of 1
zadd "subway:K" 1 Tokyo 
# add 3 elements with score  5 2 2
zadd "subway:K" 5 Shin 2 Etchu 2 Hatchb

# get elements in ranked order
zrange subway:K 0 -1
# retrieve showing scores
zrange subway:K 0 -1 withscores

# add element with same score
zadd "subway:K" 10 Nishi-Funabashi
zadd "subway:K" 10 Futamatashimmachi


# for elements with same score, sorting uses lexicological ordering
zrange subway:K 0 -1


# find associated score of element
zscore "subway:K" Tokyo

# find ranking of element (0 for first ranked, 1 for second ranked, and so on)
zrank "subway:K" Tokyo


# count number of members between scores (inclusive)
zcount "subway:K" 2 5

# find stations between the 2nd and 5th stop
zrangebyscore "subway:K" 2 5

# remove elemnt(s) by valus
zrem "subway:K" Shin

# Quiz

# execute:
zadd q-1 10 a 20 b 30 c 40 d
# question: What is the Rank of of "b" element?
# answer: 1 (ZRANK q-1 b)

# question: Can members be added to a Sorted Set with the same score?
# answer: yes (disambiguation happens using lexicological ordering)

# question: Can elements of a Sorted Set have the same Rank?
# answer: no

# question: Can you have two elements in a Sorted Set with the same value but different rank?
# answer: no, the values need to be unique


# set-based operations for sorted sets but results can only be stored in another sorted set
# one can perform intersection and union, but not a difference

# Sorted sets use cases
- Leaderboards for online games:
  # element value: user id or screen name
  # 6 players entries with respective point totals
  ZADD leaderboard 90 jane 010 john 75 bob 67 kevin 88 mel 22 kate
  # use the point total as the natural score for ordering
  # jane gets 50 point bonus
  ZINCRBY leaderboard 50 jane
  # get top 3 scores
  ZREVRANGE leaderboard 0 2 withscores
  # reduce (cap) the size of the list to top 3
  ZREMRANGEBYRANK leaderboard 0 -4
- Priority queue
  # elements can be added in any order, but they will be ordered by score
  ZADD priorityqueue 1 p1-item1 2 p2-item1 3 p3-item1 1 p1-item2
  # get next item to process in priority order
  ZRANGE priorityqueue 0 0
  # remove item from the list
  ZREM priorityqueue p1-item1
  # these statements can be combined in a transaction to make safe operations
  

# Quiz

# question: What set operators do Sorted Sets support?
# answer: intersection, union (but not difference)



####################################################################################################
# Homework 1

Can you define an Expiration time of a field in a Hash?
No: it is not possible, either use a different top-level key for that specific field, or store along with the filed another field with an expire time, fetch both, and let the application understand if it is still valid or not based on current time.


What command is used to set a value in a Hash, only if the field does not already exist?
HSETNX : Sets field in the hash stored at key to value, only if field does not yet exist. If key does not exist, a new key holding a hash is created. If field already exists, this operation has no effect.

What criteria does Redis use to determine if an operation can be performed against a key?
Datatype, Encoding of Value


If the following commands are executed:
set hw1-4 123
incr hw1-4
append hw1-4 "abc"
What does the GETRANGE command return?
getrange hw1-4 1 2

Answer:
"24"


# get a hash
hget event:UOYW-ZJAB-SZZQ-RLUJ name


The Sorted Set invoice_totals in the sample data, contains the order total as the score and the order id as the value, for each sale made.
What is the order total, for the order with the highest order value?

zrange invoice_totals 0 -1
zrange invoice_totals 0 -1 withscores
# ordered by order value => the last element has the highest order


If the following commands are executed:
sadd hw1-7 "hello"
spop hw1-7
exists hw1-7

answer: 0

can use 'sscan hw1-7 0 match *' at each step to check the set



If a Sorted Set is created as follows:
zadd hw1-8 1 a 2 b 3 c 4 d 5 e 6 f
What command would return members with a score greater than 3, regardless of the current members of the Sorted Set?

answer: zrangebyscore hw1-8 (3 +inf


can use the following to show the ordered set
zrange hw1-8 0 -1 withscores





####################################################################################################
## WEEK 2
####################################################################################################


####################################################################################################
# Capped Collections

# cardinality of collection
# lists:
LLEN key
# sets:
SCARD key
# sorted sets
ZCARD key

# Capped collections: retain only a subset of members
# examples:
- leaderboard game: retain only top 3 for retain purposes
- recent posts in activity stream

# for a list
# trim what to retain by choosing index, the rest is dropped
LTRIM key start stop

# example with list:
# list with six elements
rpush list-one a b c d e f

# show cardinality
llen list-one
# print all elements
	lrange list-one 0 -1

# keep indices 0 to 4 (a to e, drop f) => a b c d e
ltrim list-one 0 4

# start index 0, stop index -2 (keep a b c d)
ltrim list-one 0 -2

# cardinality of list-one (4 elements remain)
llen list-one

# push z on the left (z a b c d)
lpush list-one z

# bring cardinality down to 4 again (z a b c)
ltrim list-one 0 3

# pattern: add element with rpush/lpush, cap the collection with ltrim


# for sorted lists, the ltrim equivalent is
ZREMRANGEBYRANK key start stop
# but instead of retaining, removes elements between start and stop


# pattern: add element with zadd, cap the collection with zremrangebyrank

# sorted set of  6 elements with scores
zadd sortedset-two 1 a 2 b 3 c 4 d 5 e 6 f

# print out the sorted set with scores
zrange sortedset-two 0 -1 withscores

# remove elements from the 5th to the highest scoring element, remove 'f'
zremrangebyrank sortedset-two 5 -1

# remove last element, start at index 4 since array is shorter now
zremrangebyrank sortedset-two 4 -1


# add an element with high sore
zadd sortedset-two 26 z

# trim the lowest scoring element
zremrangebyrank sortedset-two  0 0



# set operations with sets and sorted sets

# two sorted sets, one for each event
zadd sales:judo 1500 june 2000 bill 200 mary
zadd sales:wrestling 1800 bill 1000 bob 800 mary
# find intersection
zinterstore promo:taekwondo 2 sales:wrestling sales:judo aggregate sum

# sorted set commands work on unsorted sets too

# create (unsorted) wait list for taekwondo => no scores
sadd waitlist:taekwondo emma bill mary
# create an intersection of the unsorted set with the two sorted ones
# no scores => add the weights, 3d weight (1000) is use as score for that
# Note: in this example we are using the max aggregation, not sum!
zinterstore promo:taekwondo 3 sales:wrestling sales:judo waitlist:taekwondo weights 1.2 0.8 1000 aggregate max

# show all value
sscan waitlist:taekwondo 0 match *

# find unique number accross a number of sets
sadd venues:Athletics "IP Garden" "Olympic"
sadd venues:Judo "Tokyo Stadium"
sadd venues:Football "Nippon Budokan" "Sapporo Dome"
#
sunion venues:Football venues:Judo venues:Athletics

# sorted sets: zunionscore
zadd events:capacity 60102 "Closing Ceremony" 1000 "Table  Tennis" 6000 "Skateboarding"
zadd events:sales -200 "Table Tennis" -5900 "Skateboarding"
# find availability by combining the two sorted sets
# no weights, so defaults 1 are used
zunionstore events:availability 2 events:capacity events:sales aggregate sum

####################################################################################################
# Use Case 01: Faceted Search

# Problem: attribute search for events at the Redis game
# 3 techniques
- object inspection
- faceted search
- hashed index

# Context: redis games, a sporting event to be held in Tokyo in 2020
# Search for events based on attributes. example attributes to search by
- disabled access available: yes/no
- medal event: yes/no
- event venue: string

# traditional approaches:
- secondary indexes
  - storage and maintenance
  - compound indexes
- full text searches (solr, lucene)
  - complexity
  - eventual consistency

# Faceted search / inverted index: an alternative to the above traditional approaches
- simple navigation and classification
- search accross multiple criteria
- filter accross multiple criteria

# domain object:
- disabled access
- venue
- medal event

# show all collections present in a db, returns a set
scan 0 match *


# Object Inspection method
Regardless of the distribution of values for one or more attributes that need to be matched, every matching key will always need to be retrieved and inspected. In a relational database, this is analogous to performing a FULL TABLE SCAN without indexes.
For very small numbers of keys (for example fewer than 100), this may be still ok. But it's clearly not appropriate for millions of keys.

# Faceted Search
There are two limiting factors for faceted searches using Sets. Firstly is the data distribution of matching attribute values. The second is the number of attributes being matches.
This pattern relies on SINTER, which has a time complexity of O(N * M), when N is cardinality of the smallest Set and M is the number of Sets. So as the Cardinality of smallest set increases or the number of attribute being matched (i.e. the number of Sets be be examined) increases, then the cost of this method increases.
Submit Some problems have options such as save, reset, hints, or show answer. These options follow the Submit button.

# Hashed faceting
The hashed faceting method will result in a Set which contains keys for each matching object with the attribute values being searched for.
The limiting factor is therefore the cardinality of the of number of matches for any given attribute combination.

Summary:
- use of sets to solve domain problems
- redis does not support seconday indexes
- faceted search
  sinter
  data and cardinality
- hashed search creates a compound value, simplifying the query

# Big O Notation and Redis Commands
- sadd: time complexity O(1) for each element, so O(N) to add N elements when the command is called with multiple arguments
- redis commands are atomic <- redis single-threads all command executions in order to achieve this
- O(1) commands are constant time, independent of cardinality. redis O(1) commands: APPEND, EXISTS, GET, SET, HGET, LPUSH, rpop
- DEL: O(1) when removing a string datatype, O(N) when multiple keys are being removed, and O(M) when the key removed contains a list, set, sorted set, or hash. UNLINK is prefered to DEL since it is a non-blocking command.
- SINTER key [key]: time complexity of O(N*M) worst case where N is the cardinality of the smallest set and M is the number of sets
- LRANGE key start stop: time complexity of O(S+N), where S is the distance of start offset from HEAD for small lists, from nearest end (HEAD or TAIL) for large lists. N is the number of elements in the specified range


# Execution time of commands: things to consider
- Calculation for time complexity of the command
- Cardinality of the data (number of elements in the set). Remember offset cost. Hashing has a constant time for accessing any field in the set
- Multiplying factor: e.g. sinter, each additional set adds to the multiplying factor
- Clock times are not O time. Always test with production volumes to measure the time, but use the above factors when designing your system.




In the faceted search chapter, we explored how to optimize searches based on categories. How many Venues have disabled_access = True?

Hint: Take a look at the key fs:disabled_access:True

Pick one answer
7
31
32
83
unanswered


####################################################################################################
## WEEK 3
####################################################################################################


####################################################################################################
# Transactions
- commands queued
- applied in single operations
- no nesting of Transactions


Transactions are simply a serialized queue of pending commands that Redis will execute sequentially. Since Redis doesnâ€™t execute a transaction until all queued commands are executed with an EXEC command, DISCARD simply needs to throw away this list of pending commands.

Unlike other Databases, there are no command to undo in Redis, because commands are only applied when EXEC is called.

In a queued set of commands, changes made in that Transaction are visible to the subsequent commands. Therefore, if you perform a SET, INCR or other command that changes a value, and subsequent retrieval via a GET, HGET, LPOP etc., will see the key modified by the prior commands in the transaction.

# Optimistic Concurrency Control / Locking
- Observe changes in one or more keys through declaration of interest
- Abort transaction if observed key changed (by another process)
- Commands:
  watch key <- before transaction start
  unwatch -> removes all keys
- keys automatically unwatched after successful transaction


Commands will get queued up in a Transaction before they are executed. The set of commands in the Transaction is executed sequentially as an atomic block, so no other command can interleave. But the value an command will observe, will be the current value the system sees.

WATCH commands need to be executed before the Transaction is started with MULTI.

All data types in Redis can be watched.

Transactions Recap
- Queued commands
- Executed or discarded
- Keys can be watched (and unwatched)

# clients
CLIENT LIST

####################################################################################################
# Object storage with hashes
- think of the hash as a mini key-value store within the key

A simple Object storage
- store the serialized object in Redis as a string in either binary or text
- deserialize the data structure when you read it from Redis
but what if you need to access a single part of that structure or increment one value within it? read entire structure, transport over network, deserialize, change, serialize, transport over network, write to Redis

Hash data type is more efficient for this purposes
- hashes are schemaless
- mechanism to map each attribute in a field within the hash


HLEN will return the length or cardinality of the hash.
HKEYS will return all the field names, HVALS all the values.

Hashes allow individual fields to be manipulated. This saves CPU, Network and other resources when only a single of a subset of fields are required. 
However, you cannot expire fields within a hash, the expiration can only be set on the Key, which therefore includes all fields.

Redis simply manages key only. There is no notion, implicit or explicit about the relationship or dependency between keys. If any do exist, then it is the responsibility for the developer and administrator to manage.


The WATCH command is used to implement optimistic concurrency control. This ensures that if any WATCHed key is modified during the lifetime of a transaction, that the transaction will be safely aborted.

For this use case, it guarantees that key that holds the event details has not been modified by another client or connection between this code reading and modifying the key.

####################################################################################################
# storing complex objects
- redis modules: ReJSON, Graph
- hash for each object
- in addition can store the relationship ends in a set to provide the abibility to provide related items more simply
- flatten the hierarchy

####################################################################################################
# inventory control
A Transaction can be made up of Read and Write commands. The reason why the HGET was called outside of the Transaction, is that the current value is required because it is tested in the next line of code.
If the HGET was queued in the transaction, then this variable would not have a value.

Summary, Inventory Control:
- object storage
- transaction to control multiple writes
- simple state machines

# homework
- Commands run with a MULTI-EXEC block are executed atomically.
- A single WATCH command can observe one or more keys.
- WATCH can be called multiple times before MULTI is executed. The effects are cumulative. Once the MULTI has been executed, a WATCH command cannot be executed until the Transaction is finalized with either EXEC or DISCARD.
- DISCARD throws away queued up commands. In a Transaction, the commands are not applied until the EXEC command is executed, so there are no commands to undo.
- When an attempt is made to queue a command with a syntax error, then the Transaction is automatically marked as invalid. If EXEC is called, then the Transaction will be discarded.
If the Transaction is dependent on a watched key(s), and that key changes, then the Transaction is also automatically discarded when EXEC is called.
If a queued command operates on the wrong datatype, for example exuting an INCR on a List datatype, then Redis skips this command but continues to execute the subsequent commands in the queue. So in this circumstance, it does not cause the Transaction to fail.
- There are a number of ways to store an object with relationships and hirerchies in Redis. Which of the techniques you use will depend on your use cases, operations you need to perform, the cardinality of data and other factors that will influence your decision.
Which techniques can you use to store an object with relationships or hierarchies?
Serialize the object into a String datatype
Flatten the relationships and hierarchy into fields in a Hash
Normalize the structure into multiple Hashes
Normalize the structure into multiple Hashes and Sets



####################################################################################################
## WEEK 4
####################################################################################################

# Bit Data
- Bitfields & Bit Arrays
- Compact, optimized structures
  - histogram of counters
  - linux file permissions
- Commands to manipulate Bitfields
- No explicit Bit data type
- Commands to operate on Strings

examples
# set unsigned 8 bit value at the offset 0 to value 42
bitfield mykey set u8 0 42
# and retrieve it
bitfield mykey get u8 0
# increment values
bitfield mykey incrby u8 0 1
# type => string
type mykey
# object encoding => raw (not string)
object encoding mykey


# Bit fields: type and size of fields
# index by offset. smallest index: highest order bit, left
# also index by position of the field itself: especially useful with uniform-sized Bitfields
# subcommands of bitfield command
- get, set, incrby: require type to be specified
- type
  - Signed (i) or Unsigned (u)
  - Size in bits
- limits
  - up to i64 and u63
- no schema


examples
# set unsigned 8 bit value at offset 0 to value 2
bitfield bf1 set u8 0 2
# retrieve (2)
bitfield bf1 get u8 0
# retrieve the key with 'get', hexadecimal representation of integer 2 ('\x02')
get bf1


# set unsigned bitfield value specifying the offset by position (position 2 = #1)
bitfield bf2 set u8 #1 5
# retrieve using position and offset
bitfield bf2 get u8 #1 get u8 8 (5, 5)
# get key ("\x00\x05")
get bf2


# Quiz
Redis considers a bitfield as a array of bits. The least significant bit, is the left most bit. Consider this example:
                        1 1 1 1 1 1
  0 1 2 3 4 5 6 7   8 9 0 1 2 3 4 5
+-----------------+-----------------+
| 1 0 0 0 0 0 0 0 | 0 1 0 1 1 0 1 0 |
+-----------------+-----------------+
The most significant bit of the first byte is a position zero, and has the value 1. It is not the bit at position 7, which is the least signifcant bit of the first byte.

The Hash or pound sign is used to indicate the position by offset, based on the type provided. This simplifies calculating offsets.


# Bit Arrays
- manipulation of individuals bits within the string data type
- think of it as a string from left to right with the most significant bit the first byte at index 0
- getbit, setbit: set and restore specific bits
- bitfield is preferred: a superset of getbit setbit
- bitcount with count the number of bits in a range or entire string that are set
- bitcount uses byte offset as opposed to the other commands that use bit offset
- bitop: bytewise operations (or, and)

# Quiz
Correct
BITPOS will return the position of a bit, either set or unset depending on the arguments passed.
Incorrect
GETBIT gets the bit at the given offset.
BITCOUNT will return the number of set bits, but not the position.
BITFIELD allows bits to be retrieved.
BITOP allows logical operators to be applied to bitfields.
SETBIT sets or clears the bit at the given offset.

Given the following commands are executed:
bitfield  ba-q1 set u8 #0 42
bitfield  ba-q2 set u8 #0 19
bitop and ba-q3 ba-q1 ba-q2
What does the following command return?
bitfield ba-q3 get u8 #0

Both BITFIELD commands will set the two binary values at position zero, or at the first byte of each key.
The BITOP command performs a logical AND on the binary values
     ba-q1 0 0 1 0 1 0 1 0
     ba-q2 0 0 0 1 0 0 1 1
AND
     ba-q3 0 0 0 0 0 0 1 0
The resulting value is the binary value 1 0 (or two in decimal).


# Use cases
- counters
- histograms
  - bitfield hist incrby u32 #23 1
  - bitfield hist get u32 #23
- permission bits & masks
  - bitop xor file1 request file2


# Seat reservations
- Seat map maintained for the event
- customer can find blocks of seats that match their requirement
- seats can be reserved and booked once and only once
- concurrent bookings of disparate seats are allowed


export PYTHONPATH=/Users/$(whoami)/Code/redis-uni

# Quiz
A U32 is an unsigned 32 bit field, so all 32 bits are available. If this value had been defined as an I32, that is a signed 32 bit value, then only 31 bits would have been available, since one bit would be required to store the sign.

BITCOUNT returns the count of the number of set bits only.
BITPOS can be used to find the index of the first set or unset bit.


# Pub / Sub
- simple syndication
- patterned syndication
- use case
- simple syndication
  - publish channel message
  - subscribe channel
  - unsubscribe channel
- patterned syndication
  - psubscribe pattern
  - punsubscribe pattern
- admin
  - pubsub subcommand argument


# Quiz
A client can subscribe to one or more channels in a single or multiple SUBSCRIBE commands.

Redis allows a byte stream to be passed as the message. This allows for simple Text values and numbers to be sent, along with a byte stream - that could represent a serialized JSON object, for example

####################################################################################################
####################################################################################################
####################################################################################################
####################################################################################################